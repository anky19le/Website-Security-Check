#!/usr/bin/python
# -*- coding: utf-8 -*-

from flask import Flask, render_template, redirect, url_for, request, \session
import requests
import pymongo
from pymongo import MongoClient
from http.server import BaseHTTPRequestHandler, HTTPServer
from datetime import datetime
import re
import sys
import json
import os
import http.client

client = MongoClient('localhost', 27017)

app = Flask(__name__)
global user_data


@app.route('/run', methods=['GET', 'POST'])
def run1():

    global user_data

    user_data = {}

    user_data['pro_name'] = request.form['pro_name']
    user_data['Tagname'] = request.form['Tagname']
    user_data['Attack_Vector'] = request.form['Attack_Vector']
    injection = user_data['Attack_Vector']
    user_data['API_Type'] = request.form['API_Type']
    method = user_data['API_Type']
    user_data['protocol'] = request.form['protocol']
    user_data['usrtxt'] = request.form['usrtxt']
    user_data['apidata'] = request.form['apidata']
    user_data['header'] = request.form['header']
    user_data['scan_id'] = request.form['scan_id']
    apiarray = user_data['usrtxt']
    head = user_data['header']
    jhead = json.dumps(head)

  ## select attack vector file according to injection type given by pen tester 
    if injection == 'SQL':
        attack_vector_file = 'sqli.txt'
    elif injection == 'XSS':
        attack_vector_file = 'xss.txt'
    elif injection == 'OS Commands':
        attack_vector_file = 'os.txt'
    elif injection == 'NoSQL':
        attack_vector_file = 'nosql.txt'
    elif injection == 'LDAP':
        attack_vector_file = 'ldap.txt'

    id=0
    attack_strings_file = open(attack_vector_file, 'r')    ## open attack vector file
    attack_strings_list = attack_strings_file.readlines()  ## read all attack strings as lines
    apis = apiarray.split(',')                             ## seperate APIs from multiple API array   

    rjson1 = [ ]
    rjson2 = {
                'DateTime': datetime.now(),
                'scan_id': user_data['scan_id'],
                'Project_Name': user_data['pro_name'],
		'Tagname' : user_data['Tagname'],
		'Injection_Type':injection,
		'API_Type':method,
             }
   
   
    for api in apis:
        if method == 'Post' or method == 'Put':
            if re.search('\{\}', api):  ## search for '{ }' brackets in API
                print ('************************************** New URL ***************************************************')
                print ('\n')
                print (api)

                for attack_string in attack_strings_list:
                    attack_str = re.sub('\n', '', attack_string)  ## remove the new line char at the end of line
                    if attack_str == '':         #ignore blank lines
                        continue

                    apiline2 = re.sub('\{\}', '"{}"', api)  #enclose the {} in double quotes

                    apiline2 = re.sub('\{\}', attack_str, apiline2)  ## replace all occurances by the same attack string

                    apidata1 = apiline2

                    print ('---------- Next Request ----------')
                    print (apiline2)                        ## print the new request generated
                    print ('---------- Response ----------')
                    r = requests.post(api, apidata1)       ## 
                    print (r)                              
                    rstr = str(r)
                    rc = re.findall(r'\d+', rstr)          ## find response code from response
                    for rc in rc:
                    	rcode = rc
                    rcode = int(rcode)                     ## convert rcode into integer format
                    print (rcode)                          ## print response code
                    print (r.text)                         ## print Response
                    print ('---------- End Response ----------')
                    print ('')
                    
                      ## append data related to one request(tag id) into rjson1. A unique Tagid is generated by concatenating unique scanid with id. i.e. Tagid=scan_id+id 
                    rjson1.append({'Tagid': user_data['scan_id']+str(id),'Request': apidata1, 'Response_Code':rcode,'Response': r.text,})
                    id = id + 1
        ## for GET and DELETE method         
        else:
            if re.search('\{\}', api):    ## search for '{ }' brackets in API
                print ('************************************** New URL ***************************************************')
                print ('\n')
                print (api)

                for attack_string in attack_strings_list:
                    attack_str = re.sub('\n', '', attack_string)   ## remove the new line char at the end of line
                    if attack_str == '':  # # ignore blank lines
                        continue

                    apiline2 = re.sub('\{\}', '"{}"', api)  # # enclose the {} in double quotes

                    apiline2 = re.sub('\{\}', attack_str, apiline2)  ## replace all occurances by the same attack string

                    url = apiline2

                    print ('---------- Next Request ----------')
                    print (apiline2)      ## print the new request generated

                    print ('---------- Response ----------')
                    r = requests.get(url)    ## get the complete response in r
                    rstr = str(r)
                    rc = re.findall(r'\d+', rstr)
                    for rc in rc:
                    	rcode = rc
                    
                    rcode = int(rcode)  ## convert Response Code in integer format
                    print (rcode)       ## print response code
                    print(r.text)       ## print Response
                  
                    print ('---------- End Response ----------')
                    print ('')
        
                    ## append data related to one request(tag id) into rjson1. A unique Tagid is generated by concatinating unique scanid with id. i.e. Tagid=scan_id+id 
                    rjson1.append({'Tagid': user_data['scan_id']+str(id),'Request': url, 'Response_Code':rcode,'Response': r.text,})
                    id = id + 1
   
    rjson2['cnt'] = id      ## cnt is total count of requests and responses
    rjson2['API'] = rjson1
   
    db = client['Cyber1']       ##  Create a database of name Cyber1
    response = db.collection    ##  create a Collection of name response
    db.response.insert(rjson2)  ##  insert complete document related to one scan_id into database

    return ('success');


if __name__ == '__main__':
    app.run(port=8003)


			
			
			
			
